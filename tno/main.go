package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"reflect"
	"strings"

	"golang.org/x/tools/go/gcexportdata"
)

type Generator struct {
	buf         bytes.Buffer   // Accumulated output.
	pkg         *types.Package // Package we are scanning.
	trimPrefix  string
	lineComment bool
	fileName    string
	tt          []TableType
}

// format returns the gofmt-ed contents of the Generator's buffer.
func (g *Generator) format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		return g.buf.Bytes()
	}
	return src
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *Generator) Flush() {
	err := ioutil.WriteFile(strings.ReplaceAll(g.fileName, ".go", "_tno.go"), g.buf.Bytes(), os.ModePerm)
	if err != nil {
		panic(err)
	}
}

func (g *Generator) printHeader() {
	// Print the header and package clause.
	g.Printf("// Code generated by \"sqler %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	g.Printf("\n")
	g.Printf("package %s", g.pkg.Name())
	g.Printf("\n")
	g.Printf("import \"github.com/didi/gendry/builder\"\n") // Used by all methods.
}

func main() {
	var typeName = "DealerBusinessmanHistory"

	var dir string
	flag.StringVar(&dir, "d", "", "dir to scan")
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of checkimpl:\n")
		flag.PrintDefaults()
	}
	flag.Parse()
	dir = "./testdata"
	fset := token.NewFileSet()
	pkgs, err := parser.ParseDir(fset, dir, func(fi os.FileInfo) bool { return !strings.HasSuffix(fi.Name(), "_tno.go") }, parser.ParseComments)
	if err != nil {
		panic(err)
	}
	fs := []*ast.File{}
	for _, pkg := range pkgs {
		for _, f := range pkg.Files {
			fs = append(fs, f)
		}
	}
	config := &types.Config{
		Error:    func(error) {},
		Importer: newImporter(fset),
	}
	info := &types.Info{
		Types:  map[ast.Expr]types.TypeAndValue{},
		Defs:   map[*ast.Ident]types.Object{},
		Uses:   map[*ast.Ident]types.Object{},
		Scopes: map[ast.Node]*types.Scope{},
	}
	gMap := map[string]*Generator{}
	_, err = config.Check("", fset, fs, info)

	for k, v := range info.Defs {
		if v == nil {
			continue
		}
		if typeName != v.Name() {
			continue
		}
		t := info.TypeOf(k)
		if goType, ok := t.Underlying().(*types.Struct); ok {
			fName := fset.File(k.Pos()).Name()
			if gMap[fName] == nil {
				gMap[fName] = new(Generator)
			}
			g := gMap[fName]
			g.fileName = fName
			g.printHeader()

			typeName := k.Name
			fields := []string{}
			fieldMap := []string{}
			for i := 0; i < goType.NumFields(); i++ {
				tag := reflect.StructTag(goType.Tag(i)).Get("db")
				if tag == "" {
					panic("bad tag")
				}
				fieldMap = append(fieldMap, fmt.Sprintf(`"%s":_v.%s,`, tag, goType.Field(i).Name()))
				fields = append(fields, `"`+tag+`"`)
			}

			g.tt = append(g.tt, TableType{
				Package:     v.Pkg().Name(),
				TableStruct: typeName,
				TableFields: fmt.Sprintf("[]string{%s}", strings.Join(fields, ",")),
				TableMap:    strings.Join(fieldMap, "\n"),
			})
		}
	}
}

type TableType struct {
	Package     string
	TableStruct string
	TableFields string
	TableMap    string
}

var sqlTmpl = `

type internalUser struct{
}

func (internalUser)schema() string{
	return User{}.schema()
}

func (internalUser)fields() []string{
	return _fields
}


func (internal * internalUser)GetUserByID(db DbInterface ,id int64) (_v User,err error){
	where:=map[string]interface{}{
		"I_ID":id,
	}
	query,args,err:=builder.BuildSelect(internal.schema(),where,internal.fields())
	if err!=nil{
		return 
	}
	
	err=db.Get(&_v,query,args...)
	return
}

func (internal * internalUser)GetUserByIDs(db DbInterface,ids []int64) (_vs []User,err error){
	where:=map[string]interface{}{
		"I_ID in":ids,
	}
	query,args,err:=builder.BuildSelect(internal.schema(),where,internal.fields())
	if err!=nil{
		return 
	}
	
	err=db.Select(&_vs,query,args...)
	return
}

func (internal * internalUser)Insert(db DbInterface, _v User) (_us []User,err error){
	data:=map[string]interface{}{
		_fieldsMap
	}
	
	query,args,err:=builder.BuildInsert(internal.schema(),[]map[string]interface{}{data})
	if err!=nil{
		return 
	}
	
	_,err=db.Exec(query,args...)
	return
}

func (internal * internalUser)Delete(db DbInterface, id int64) (err error){
	where:=map[string]interface{}{
		"I_ID":id,
	}
	
	query,args,err:=builder.BuildDelete(internal.schema(),where)
	if err!=nil{
		return 
	}
	
	_,err=db.Exec(query,args...)
	return
}
`

var newImporter = func(fset *token.FileSet) types.ImporterFrom {
	return gcexportdata.NewImporter(fset, make(map[string]*types.Package))
}
